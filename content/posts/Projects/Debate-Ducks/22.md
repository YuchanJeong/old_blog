---
title: "[Debate-Ducks] "
date: 2022-08-16
categories:
  - <Projects>
tags:
  - "'Debate-Ducks'"
  - (Devlog)
---

## 로그인/로그아웃 시 좋아요 여부와 투표 여부 반영 문제

_\*[Issue](https://github.com/SuSang-YuHee/Debate-Ducks-Client/issues/104)_

**\# 문제**

로그인과 로그아웃 시 좋아요 여부와 투표 여부가 제대로 반영되지 않는 문제 발생했다. (좋아요 여부와 투표 여부는 사용자 아이디와 토론 아이디를 받아서 표시하게 되는데 이게 제대로 반영되고 있지 않았음)

**\# 원인**

이전에 로그인 시 잘 반영되는걸 확인 했었고, 이후 로그아웃 시 잘 반영 되는걸 확인 했었다. 하지만 로그아웃 기능 개발 후 로그인 시 잘 반영되는지 확인하지 않았던 것을 깨달았다.

그래서 로그아웃 시 했던 처리를 살펴보자 치명적인 문제가 있음을 깨달았다. (그 당시에 이력서 제출 전에 작업을 끝내기 위해 빠르게 개발하느라 확인이 미흡했음. 급할수록 사전 구상을 덜하고 작업에 들어가기 때문에 사후 확인을 더욱 철저하게 할 필요가 있는데...반성합니다🙏)

로그아웃은 따로 api가 없어서 (서버에서 미구현) 토큰을 지우고 쿼리에 저장된 사용자 정보를 직접 `setQueryData`로 날리는 방식으로 구현했고 잘 작동했다. 그래서 그 직후 좋아요 여부와 투표 여부도 `useEffect`를 사용해 비슷하게 구현했다. 하지만 해당 방식으로는 현재 페이지의 좋아요 여부와 투표 여부만 변경되는 치명적인 문제가 있었다. 그 당시에는 한 페이지에서만 확인을 끝내서 발견하지 못했던 문제이다.

추가로 내가 처음 이 문제를 인지하게된 부분인데, 로그인 상태에서 새로고침 시 좋아요 여부와 투표 여부가 null로 변경되는 문제가 있었다. 이유는 새로고침 시 사용자 정보를 받기 이전에 `useEffect` 내부의 로직이 작동해 쿼리에 null이 저장되고 기본 설정이 `staleTime: infinity;`기 때문에 사용자 정보를 받은 뒤 추가 요청이 일어나지 않아서 발생한 문제이다.

```ts
// Bad!! 로그아웃 시 좋아요 여부와 투표 여부 처리
useEffect(() => {
  if (!user.data) {
    queryClient.setQueryData([queryStr.hearts, `${debateId}`], () => null);
    queryClient.setQueryData([queryStr.votes, `${debateId}`], () => null);
  }
}, [debateId, queryClient, user.data]);
```

**\# 해결**

우선 `invalidateQueries`는 `useMutation` 내부에서 사용하지 않으면 작동하지 않는다. 하지만 현제 로그아웃 api가 없어서 `useMutation`을 사용하기 애매했다. 그래서 쿼리의 값과 상관없이 로그아웃 상태에서 좋아요 여부가 false가 나오게 조건에 사용자 정보 여부를 추가했다. (투표도 마찬가지)

```ts
heart.data && user.data ? styles.heart_fill : styles.heart_empty;
```

하지만 이렇게만 처리할 경우 사용자가 로그아웃 후 다른 아이디로 로그인했을 때 기존 쿼리에 저장된 값이 유지되는 문제가 있었다. 그래서 로그인 시 해당 쿼리들을 무효화하는 방식을 사용했다. (기존에는 로그인 시 토큰을 쿼리가 아닌 로컬 저장소에 저장하기 때문에 따로 `useMutation`을 사용하지 않았으나 쿼리 무효화를 위해 변경)

```ts
queryClient.invalidateQueries([queryStr.users]);
queryClient.invalidateQueries([queryStr.hearts]);
queryClient.invalidateQueries([queryStr.votes]);
```

Ps. 가장 쉽게 처리하는 방법은 `staleTime`을 짧게 두는 것이다. 하지만 그럴 경우 요청의 수가 많아지게 되고 이를 원하지 않아 다른 해결 방법을 고민했다.

Ps. 이번에 문제가 발생한 이유는 A를 개발하고 확인한 뒤, B를 개발하고 확인할 때 B만 확인했기 때문이다. 하지만 개발이 쌓일수록 앞의 모든 기능을 직접 하나씩 확인하기 힘들기 때문에 테스트 주도 개발의 필요성을 절실히 깨달았다.

##
