---
title: "[땡땡능력시험] DynamoDB 연결 및 기능 구체화"
date: 2022-08-27
categories:
  - <Projects>
tags:
  - "'땡땡능력시험'"
  - (Devlog)
---

## 로컬 DynamoDB 연결

우선 Docker를 사용해서 로컬에 DynamoDB를 만들었다. 그 후 CLI로 테이블을 만들고 AWS-SDK로 아이템의 생성 및 테이블의 조회를 테스트 했다.

하지만 CLI에서 만든 테이블이 AWS-SDK로 확인했을 때 조회되지 않았다. sharedDb 옵션을 사용하지 않으면 프로그램별로 DB가 따로 생성되기 때문이었다. [[참조]](https://docs.aws.amazon.com/ko_kr/amazondynamodb/latest/developerguide/DynamoDBLocal.UsageNotes.html)

그래서 sharedDb 옵션을 포함한 DynamoDB를 다시 만들었으며, 추가로 GUI로 확인할 수 있게 dynamodb-admin을 사용했다.

[[참조]](/posts/studies/db/dynamodb/1/) - [DynamoDB] 시작하기 (My Blog)

## DB 구체화

이번 프로젝트에서 DB 구성 중 가장 신경 쓰는 부분은 서버(클라이언트)의 부담 최소화이다. 이 프로젝트에서 한번 생성된 시험은 같은 형태로 여러 사용자들에게 보여줄 것이기 때문에 정적으로 생성하고, 변경 사항이 있을 때만 해당 페이지를 다시 업데이트해서 정적으로 배포할 것이다.

목록과 내용을 다 불러오고 다 저장해 두는 방식이 있음...
이 때 목록의 경우 고민이 생긴다. 시험의 수가 얼마 없는 초기에는 시험에 변경 사항이 있을 때 마다 전체 목록을 업데이트 해줘도 되겠지만 시험의 수가 많을 때는 서버에 부담을 줄 수 있다. 그리고 DynamoDB의 경우 특정 아이템만 조회할 때 쿼리가 완료된 후 결과가 반환되기 전에 적용되기 때문에 동일한 양의 읽기 용량을 사용한다. 그래서 목록에 사용되는 항목만 따로 저장해서 목록은 상위 몇개의 개시물만 모아서 먼저 보여주고 그 뒤로는 무한 스크롤을 사용해서 그때 그때 요청하도록 설계할 예정. 이렇게 될 경우 시험이 하나 생성될 때 마다 빌드 해야하지만 어차피 아래 검색 때도 해야하고 또 결국 시험을 만드는 횟수보다는 아무래도 조회가 더 많을 꺼라서 이 편이 사용자는 첫 페이지 바로 보여서 좋고 목록 반영까지 시간이 잠시 걸ㄹ릴 수 있다고 안내 필요할 듯...바로 게시물로 이동 시켜주면 일단 폴백 될 꺼고...목록

점수 경우도 따로 하자 이거 같은 경우는 시험 다 끝나고 나서 딱 보여주면 되니까 ssg 자주 업데이트 될 필요 있는 것들

그리고 검색의 경우 부분 일치 검색을 사용하기 위해서는 쿼리를 사용할 수 없이 스캔을 사용해야 해서 피하고 싶었다 (필터만 됨). 그래서 따로 주제와 영역을 모은 테이블을 만들고 그 곳에 글자만 저장해서 그걸 정적 배포 검색 창에서 검색할 때 그거 바탕으로 해당사항 없음 있음 검색 결과에 주제와 영역 분히하자, 합쳐서 set으로 중복 없에는 방식도 고민 했지만 그거 보다는 이게 낳은듯. 왜냐면 검색은 검색 때 마다 일단 스캔이 필요하기 때문 그리고 첫 페이지에서 빌드시 패치하게 만들어 두면 폴백 화면을 사용자가 볼 일도 거의 없을거임.

로그인 같은 경우 / 이거 참조한 사이트가 이상형 월드컵인데 로그인이 있지만 메일 검사도 하지않고 로그인 해야지만 만들 수 있는데 사실 내가 만든 월드컵 확인하기 말고는 의미가 없다. 그리고 나는 북마크 이런거도 생각 했는데 사실 이런건 심심할 때 들어가서 살펴보고 하는 용도고 북마크한 시험도 데이터 베이스에 저장되어야할 정도로 중요한지도 모르겠다. 그리고 무엇보다 이거 테스트 해보기 이전에 이런 사이트에서 만들기위해서라지만 가입 한다는게 귀찮게 느껴지기도 했다. 당장 시험 만들고 주변에 공유해서 풀어보고 이런 웹사이트지 특별이 아이디가 중요하지 않다 생각 이상형 월드컵도 엄청 활성화된 사이트인데 작성자가 만든 게시물에 노출도 안되고 딱히 의미 없어 보였다. 그래서 시험 작성 시 비밀번호 입력할 수 있게 하고 비밀번호 알면 수정할 수 있게 만들었다. 그리고 댓글도 시험을 푼 사람이 점수 공개 비공개 설정 가능, 익명 혹은 아이디 넣고 비번 넣거나 안넣거나 (넣으면 수정, 삭제 가능) 여기도 따로 파서 끝 날때 적을 수 있게

사실 Next.js의 api나 AWS의 Lambda를 사용한 회원가입, 로그인, 인증 기능을 공부해둔 상태라 조금 아쉬웠지만 프로젝트의 목적성에는 필요없다고 판단. 다음에 잘 사용해 보겠다.

```ts
TestCovers: {
  testId: uuid, //> Hash Attribute (Sort Key)
  userId: uuid, //> Range Attribute (Partition Key)
  createdAt: string, //>
  coverUrl: string,
  category: string, //>
  area: string, //>
  totalCount: number //>
}

TestContents: {
  testId: uuid, //> Hash Attribute (Partition Key)
  createdAt: string,
  category: string,
  area: string,
  questions: {
    point: number,
    question: string,
    desc?: string | audio | image,
    choice1: string | audio | image,
    choice2: string | audio | image,
    choice3: string | audio | image,
    choice4: string | audio | image,
    answer: number,
    explanation?: string
  }[],
}[]

TestResults: {
  testId: uuid, //> Hash Attribute (Partition Key)
  totalCount: number,
  totalScore: number
}

Users: {
  userId: uuid, //> Hash Attribute (Partition Key)
  nickname: string,
  email: string,
  password: string,
  solvedTests: {
    testId: uuid,
    coverUrl: string,
    category: string,
    area: string,
    score: number
  }[],
  bookmarks: {
    testId: uuid,
    coverUrl: string,
    category: string,
    area: string,
  }[] //> 시험을 치고 나면 solvedTests로 이동
}[]

Filters: {
  filter: string,
}
```

이전에 배운거 머리로만 구현하고 들어가지 말고 구현한 기능들이 되는지 최소 단위로 테스트 하고 들어가라 다만들고 안되면 설계부터 꼬인다.

그럼 이제 테스트 해야 하는거

1. 목록 페이지와 내용 페이지 구분한 다음 on demand로 테스트 하는거해보자 [v]
2. 목록 만든 날짜 순서로 정렬 및 페이지 네이션 쿼리 + 리미트
3. 검색은 필터 미리 받아서 결과 보여주기 해당없음 이나 이런거로
4. 객체 정보 넣어 보기

뒤로가기 막기랑 새로고침 경고 주기!

##

```js
function base64Encoding(obj: object): string {
  return Buffer.from(JSON.stringify(obj), "utf-8").toString("base64");
}

function base64Decoding(str: string): object {
  return JSON.parse(Buffer.from(str, "base64").toString("utf-8"));
}

export { base64Encoding, base64Decoding };
```

### On Demand Revalidate

```ts
import type { NextPage } from "next";

const Home: NextPage = () => {
  function revalidation() {
    fetch(
      `/api/revalidate?testId=1&secret=${process.env.NEXT_PUBLIC_MY_SECRET_TOKEN}`
    );
  }

  return (
    <>
      <h1 onClick={revalidation}>revalidate</h1>
    </>
  );
};

export default Home;
```

```ts
//# pages/[testId].tsx
import { GetStaticPaths, GetStaticProps } from "next";
import { useRouter } from "next/router";

export default function Test({ test }: { test: string }) {
  const router = useRouter();

  if (router.isFallback) return <div>Loading...</div>;
  return (
    <div>
      <h1>{test}</h1>
    </div>
  );
}

export const getStaticPaths: GetStaticPaths = async () => {
  return {
    paths: [], //> build 시 만들 경로
    fallback: true, //> paths에 없는 경로일 경우 build 중 fallback 상태
  };
};

export const getStaticProps: GetStaticProps = async (context) => {
  const testId = context.params?.testId;
  const test = testId;
  console.log(context.params);

  if (testId === "0") {
    return {
      notFound: true,
    };
  }

  return {
    props: {
      test,
    },
  };
};
```

```ts
//# pages/api/revalidate.ts
export default async function handler(req: any, res: any) {
  console.log(`Revalidating-try: ${req.query.testId}`);
  if (req.query.secret !== process.env.NEXT_PUBLIC_MY_SECRET_TOKEN) {
    return res.status(401).json({ message: "Invalid token" });
  }
  try {
    await res.revalidate(`/${req.query.testId}`);
    return res.json({ revalidated: true });
  } catch (err) {
    return res.status(500).send("Error revalidating");
  }
}
```

```bash
NEXT_PUBLIC_MY_SECRET_TOKEN=
```

### 로그인 서버리스라 JWT를 사용

참조 웹 사이트는 이상형 월드컵 나름 만힝 쓰고 이와 비슷한 느낌의 기능이 될 것이기 때문

사용자 정보 수정 시에도 다 수정하려면 조회를 토론의 아이디 받아서

이거 만들 떄 참조한 사이트가 이상형 월드컵과

[[참조]](https://aws.plainenglish.io/build-a-serverless-login-service-using-aws-dynamodb-and-lambda-ce7d68248743) - AWS DynamoDB 및 Lambda를 사용하여 서버리스 로그인 서비스 구축
