---
title: "[땡땡능력시험] DynamoDB"
date: 2022-08-26
categories:
  - <Projects>
tags:
  - "'땡땡능력시험'"
  - (Devlog)
---

도커를 사용해서 연결

CLI로 테이블을 만들고 서비스는 Node.js의 AWS-SDK로 구현할 꺼

근데 테스트겸 해도 안됬음 CLI로 만들고 CLI로 조회하면 테이블이 있는데

SDK로 조회하면 안됬음

그리고 공문의 예시들이

그리고 GUI로 연결했다.

```ts
TestCovers: {
  testId: uuid, //> Hash Attribute (Sort Key)
  userId: uuid, //> Range Attribute (Partition Key)
  createdAt: string, //>
  coverUrl: string,
  category: string, //>
  area: string, //>
  totalCount: number //>
}

TestContents: {
  testId: uuid, //> Hash Attribute (Partition Key)
  createdAt: string,
  category: string,
  area: string,
  questions: {
    point: number,
    question: string,
    desc?: string | audio | image,
    choice1: string | audio | image,
    choice2: string | audio | image,
    choice3: string | audio | image,
    choice4: string | audio | image,
    answer: number,
    explanation?: string
  }[],
}[]

TestResults: {
  testId: uuid, //> Hash Attribute (Partition Key)
  totalCount: number,
  totalScore: number
}

Users: {
  userId: uuid, //> Hash Attribute (Partition Key)
  nickname: string,
  email: string,
  password: string,
  solvedTests: {
    testId: uuid,
    coverUrl: string,
    category: string,
    area: string,
    score: number
  }[],
  bookmarks: {
    testId: uuid,
    coverUrl: string,
    category: string,
    area: string,
  }[] //> 시험을 치고 나면 solvedTests로 이동
}[]

Filters: {
  filter: string,
}
```

보조키나 이런것도 이해가 안되서 열심히 찾아봤다.

필요한 검색 기능

이거 단점이 조회 시 특정 항목만 불러올 수 없는거

사실 아직 안해봐서 모르겠지만 머리로 구현은 저 목록꺼랑 따로 하고

정적으로 생성

페이지는 데이터 만든 다음 정적 증분으로 만듦.

그리고 목록은 첫 페이지는 정적 그 후로는 클라 요청으로 만들고,

무한로딩으로 하면 목록을 다 불러오고 다 저장해 두는 방식이 있음...

페이지네이션 해도
문제는 하나 추가해도 전체 다시 다 불러오는 경우 생길 수 있음

그래서 분리 해서 하도록 만들어볼 예정
목록이랑 내용이랑

이전에 배운거 머리로만 구현하고 들어가지 말고 구현한 기능들이 되는지 최소 단위로 테스트 하고 들어가라 다만들고 안되면 설계부터 꼬인다.

그럼 이제 테스트 해야 하는거

1. 목록 페이지와 내용 페이지 구분한 다음 on demand로 테스트 하는거해보자 [v]
2. 목록 만든 날짜 순서로 정렬 및 페이지 네이션 쿼리 + 리미트
3. 검색은 필터 미리 받아서 결과 보여주기 해당없음 이나 이런거로
4. 객체 정보 넣어 보기

- 태그나 검색처럼 가능한지? 일부 포함 검색은 필터링만 되서 빼기로 함  
  대신 category와 area를 모아서 제공해주자!!! findOrCreate가 없는게 아쉽다.

- 사실 갯수가 적을때야 다 불러오고 필터링 해도 상관은 없다. 하지만 미리 사용자와 게시물이 늘어 났을때를 대비하고 싶었다. 처음부터 없으면 ㄱㅊ지만 있다가 없는건 안되기 때문이다. 모든 데이터 베이스 다 뒤져볼꺼기 때문에

- 임시 저장은?? 사용자 로컬에 저장하는건 좀 이상하고 서버에 저장 하기는 만약 완성 안하면 그 시험이 자꾸 존재하는거라 관리자 페이지 같은걸로 지워주지 않으면 안되서 일단 뺌

- 필터는 둘다 조회하고 합쳐서 set으로 중복 없에주자

검색은 필수일까?

뒤로가기 막기랑 새로고침 경고 주기!

```js
function base64Encoding(obj: object): string {
  return Buffer.from(JSON.stringify(obj), "utf-8").toString("base64");
}

function base64Decoding(str: string): object {
  return JSON.parse(Buffer.from(str, "base64").toString("utf-8"));
}

export { base64Encoding, base64Decoding };
```

### On Demand Revalidate

```ts
import type { NextPage } from "next";

const Home: NextPage = () => {
  function revalidation() {
    fetch(
      `/api/revalidate?testId=1&secret=${process.env.NEXT_PUBLIC_MY_SECRET_TOKEN}`
    );
  }

  return (
    <>
      <h1 onClick={revalidation}>revalidate</h1>
    </>
  );
};

export default Home;
```

```ts
//# pages/[testId].tsx
import { GetStaticPaths, GetStaticProps } from "next";
import { useRouter } from "next/router";

export default function Test({ test }: { test: string }) {
  const router = useRouter();

  if (router.isFallback) return <div>Loading...</div>;
  return (
    <div>
      <h1>{test}</h1>
    </div>
  );
}

export const getStaticPaths: GetStaticPaths = async () => {
  return {
    paths: [], //> build 시
    fallback: true, //> paths에 없는 경로일 경우 build 중 fallback 상태
  };
};

export const getStaticProps: GetStaticProps = async (context) => {
  const testId = context.params?.testId;
  const test = testId;
  console.log(context.params);

  if (testId === "0") {
    return {
      notFound: true,
    };
  }

  return {
    props: {
      test,
    },
  };
};
```

```ts
//# pages/api/revalidate.ts
export default async function handler(req: any, res: any) {
  console.log(`Revalidating-try: ${req.query.testId}`);
  if (req.query.secret !== process.env.NEXT_PUBLIC_MY_SECRET_TOKEN) {
    return res.status(401).json({ message: "Invalid token" });
  }
  try {
    await res.revalidate(`/${req.query.testId}`);
    return res.json({ revalidated: true });
  } catch (err) {
    return res.status(500).send("Error revalidating");
  }
}
```

```bash
NEXT_PUBLIC_MY_SECRET_TOKEN=
```

### 로그인 서버리스라 JWT를 사용
